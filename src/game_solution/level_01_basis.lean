/-
Copyright (c) 2023 Jiale Miao. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jiale Miao, Yichen Feng, Lily Frost, Archie Prime
Thanks: Kevin Buzzard
-/

import game_solution.level_00_basic

/-!
# Filters

We define the filter basis in this file.

# Main Definitions

`filter_basis` : the filter basis

-/

open set

-- Let's define the filter basis:
/-- A filter basis is a nonempty collection of sets such that the intersection of 
two elements of this collection contains some element of the collection. -/
structure filter_basis (α : Type*) :=
(sets                   : set (set α))
(nonempty               : sets.nonempty)
(inter_sets {x y}       : x ∈ sets → y ∈ sets → ∃ z ∈ sets, z ⊆ x ∩ y)

variables {α : Type*}

-- A filter B is a collection of subsets, 
-- so clearly we want to do something like U ∈ B. 
@[reducible]
instance : has_mem (set α) (filter_basis α) := ⟨λ U B, U ∈ B.sets⟩

-- We can prove that every filter is actually a filter basis.
/-- View a filter as a filter basis. -/
def filter.as_basis (f : filter α) : filter_basis α :=
⟨f.sets, ⟨univ, filter.univ_mem⟩, λ x y hx hy, ⟨x ∩ y, filter.inter_mem hx hy, subset_rfl⟩⟩

-- Let's make some APIs of as_basis for convenience:
lemma filter.mem_as_basis_iff (f : filter α) (t : set α) : 
  t ∈ filter.as_basis f ↔ t ∈ f := by refl

namespace filter_basis

-- We can construct filter using filter basis:
-- The filter F generated by filter base B is te collection of all sets Fⱼ such
-- that Bᵢ ⊆ Fⱼ for some Bᵢ ∈ B.
/-- The filter associated to a filter basis. -/
protected def filter (B : filter_basis α) : filter α :=
{ sets := {s | ∃ t ∈ B, t ⊆ s},
  univ_sets := 
  begin
    simp only [exists_prop, mem_set_of_eq, subset_univ, and_true],
    exact B.nonempty,
  end,
  upward_closure := 
  begin
    simp only [exists_prop, mem_set_of_eq, forall_exists_index, and_imp],
    intros F₁ F₂ x hx₁ hx₂ hF,
    refine ⟨x, hx₁, subset_trans hx₂ hF⟩,
  end,
  inter_sets := 
  begin
    simp only [exists_prop, mem_set_of_eq, subset_inter_iff, forall_exists_index, and_imp],
    intros F₁ F₂ x hx₁ hx₂ y hy₁ hy₂,
    obtain ⟨t, ht₁, ht₂⟩ := B.inter_sets hx₁ hy₁,
    rw subset_inter_iff at ht₂,
    cases ht₂ with ht₃ ht₄,
    refine ⟨t, ht₁, subset_trans ht₃ hx₂, subset_trans ht₄ hy₂⟩,
  end }

-- The following two lemmas are directly from the definition.
lemma mem_filter_iff (B : filter_basis α) {U : set α} : U ∈ B.filter ↔ ∃ s ∈ B, s ⊆ U :=
iff.rfl

lemma mem_filter_of_mem (B : filter_basis α) {U : set α} : U ∈ B → U ∈ B.filter:=
λ U_in, ⟨U, U_in, subset.refl _⟩

-- Next, we can try to prove this lemma:
/-- The filter generated by a filter f is actually f. -/
lemma generated_by_filter_eq (f : filter α) :
  filter_basis.filter (filter.as_basis f) = f :=
begin
  ext1,
  rw mem_filter_iff,
  split,
  { intro hs,
    obtain ⟨t, ht₁, ht₂⟩ := hs,
    rw filter.mem_as_basis_iff at ht₁,
    exact filter.mem_of_superset ht₁ ht₂ },
  { intro hs,
    rw ← filter.mem_as_basis_iff at hs,
    refine ⟨s, hs, by refl⟩ }
end

/-
Now, we want to consider ≤ in filters.
When we say that a filter F ≤ filter G , it means that G is finer than or equal to F. 
In this context, being "finer" means having more sets that satisfy the conditions 
for being in the filter. The definition (every element of G is a subset of some 
element of F) captures the idea that G has, in some sense, 
more detailed or refined information than F.

This is analogous to the concept of refining a partition or a 
grid in topology or analysis. For example, in calculus, 
when we talk about partitions of an interval, a finer partition has more subintervals 
and is considered "smaller" than a coarser partition in the context of integration, even 
though it contains more elements.
-/

section order

-- Let's verify it satisfies partial order:
instance : partial_order (filter α) :=
{ le            := λ f g, ∀ ⦃U : set α⦄, U ∈ g → U ∈ f,
  le_antisymm   := λ a b h₁ h₂, filter.filter_eq $ subset.antisymm h₂ h₁,
  le_refl       := λ a, subset.rfl,
  le_trans      := λ a b c h₁ h₂, subset.trans h₂ h₁ }

theorem le_def {f g : filter α}: f ≤ g ↔ ∀ x ∈ g, x ∈ f := iff.rfl

-- Similarly, we can define partial order on filter basis:
instance : partial_order (filter_basis α) :=
{ le := λ B C, ∀ ⦃U : set α⦄, U ∈ C → U ∈ B,
  le_refl := sorry,
  le_trans := sorry,
  le_antisymm := sorry }

-- Next, let's think about how to prove this:
/--
If filter base B is a refinement of filter base C then the filter generated by B is finer
than the filter generated by C.
-/
lemma filter_basis_le_generate_le {B C : filter_basis α} (h : B ≤ C) :
  filter_basis.filter B ≤ filter_basis.filter C :=
begin
  sorry
end

end order
end filter_basis