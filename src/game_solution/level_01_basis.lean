/-
Copyright (c) 2023 Jiale Miao. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jiale Miao, Yichen Feng, Lily Frost, Archie Prime
Thanks: Kevin Buzzard
-/

import game_solution.level_00_basic

/-!
# Filters

We define the filter basis in this file.

# Main Definitions

`filter_basis` : the filter basis

-/

open set

-- Let's define the filter basis:
/-- A filter basis is a nonempty collection of sets such that the intersection of 
two elements of this collection contains some element of the collection. -/
structure filter_basis (Œ± : Type*) :=
(sets                   : set (set Œ±))
(nonempty               : sets.nonempty)
(inter_sets {x y}       : x ‚àà sets ‚Üí y ‚àà sets ‚Üí ‚àÉ z ‚àà sets, z ‚äÜ x ‚à© y)

variables {Œ± : Type*}

-- A filter B is a collection of subsets, 
-- so clearly we want to do something like U ‚àà B. 
@[reducible]
instance : has_mem (set Œ±) (filter_basis Œ±) := ‚ü®Œª U B, U ‚àà B.sets‚ü©

-- We can prove that every filter is actually a filter basis.
/-- View a filter as a filter basis. -/
def filter.as_basis (f : filter Œ±) : filter_basis Œ± :=
‚ü®f.sets, ‚ü®univ, filter.univ_mem‚ü©, Œª x y hx hy, ‚ü®x ‚à© y, filter.inter_mem hx hy, subset_rfl‚ü©‚ü©

-- Let's make some APIs of as_basis for convenience:
lemma filter.mem_as_basis_iff (f : filter Œ±) (t : set Œ±) : 
  t ‚àà filter.as_basis f ‚Üî t ‚àà f := by refl

namespace filter_basis

-- We can construct filter using filter basis:
-- The filter F generated by filter base B is te collection of all sets F‚±º such
-- that B·µ¢ ‚äÜ F‚±º for some B·µ¢ ‚àà B.
/-- The filter associated to a filter basis. -/
protected def filter (B : filter_basis Œ±) : filter Œ± :=
{ sets := {s | ‚àÉ t ‚àà B, t ‚äÜ s},
  univ_sets := 
  begin
    simp only [exists_prop, mem_set_of_eq, subset_univ, and_true],
    exact B.nonempty,
  end,
  upward_closure := 
  begin
    simp only [exists_prop, mem_set_of_eq, forall_exists_index, and_imp],
    intros F‚ÇÅ F‚ÇÇ x hx‚ÇÅ hx‚ÇÇ hF,
    refine ‚ü®x, hx‚ÇÅ, subset_trans hx‚ÇÇ hF‚ü©,
  end,
  inter_sets := 
  begin
    simp only [exists_prop, mem_set_of_eq, subset_inter_iff, forall_exists_index, and_imp],
    intros F‚ÇÅ F‚ÇÇ x hx‚ÇÅ hx‚ÇÇ y hy‚ÇÅ hy‚ÇÇ,
    obtain ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü© := B.inter_sets hx‚ÇÅ hy‚ÇÅ,
    rw subset_inter_iff at ht‚ÇÇ,
    cases ht‚ÇÇ with ht‚ÇÉ ht‚ÇÑ,
    refine ‚ü®t, ht‚ÇÅ, subset_trans ht‚ÇÉ hx‚ÇÇ, subset_trans ht‚ÇÑ hy‚ÇÇ‚ü©,
  end }

-- The following two lemmas are directly from the definition.
lemma mem_filter_iff (B : filter_basis Œ±) {U : set Œ±} : U ‚àà B.filter ‚Üî ‚àÉ s ‚àà B, s ‚äÜ U :=
iff.rfl

lemma mem_filter_of_mem (B : filter_basis Œ±) {U : set Œ±} : U ‚àà B ‚Üí U ‚àà B.filter:=
Œª U_in, ‚ü®U, U_in, subset.refl _‚ü©

-- Next, we can try to prove this lemma:
/-- The filter generated by a filter f is actually f. -/
lemma generated_by_filter_eq (f : filter Œ±) :
  filter_basis.filter (filter.as_basis f) = f :=
begin
  ext1,
  rw mem_filter_iff,
  split,
  { intro hs,
    obtain ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü© := hs,
    rw filter.mem_as_basis_iff at ht‚ÇÅ,
    exact filter.mem_of_superset ht‚ÇÅ ht‚ÇÇ },
  { intro hs,
    rw ‚Üê filter.mem_as_basis_iff at hs,
    refine ‚ü®s, hs, by refl‚ü© }
end




-- I will consider add this later after we define princpal filter.
-- Here is one challenging puzzle:
/-
lemma eq_infi_principal (B : filter_basis Œ±) : B.filter = ‚®Ö s : B.sets, ùìü s :=
begin
  sorry
end
-/

end filter_basis