/-
Copyright (c) 2023 Jiale Miao. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jiale Miao, Yichen Feng, Lily Frost, Archie Prime
Thanks: Kevin Buzzard
-/

import game_solution.level_00_basic

/-!
# Filters

We define the filter basis in this file.

# Main Definitions

`filter_basis` : the filter basis

-/

open set

-- Let's define the filter basis:
/-- A filter basis is a nonempty collection of sets such that the intersection of 
two elements of this collection contains some element of the collection. -/
structure filter_basis (α : Type*) :=
(sets                   : set (set α))
(nonempty               : sets.nonempty)
(inter_sets {x y}       : x ∈ sets → y ∈ sets → ∃ z ∈ sets, z ⊆ x ∩ y)

variables {α : Type*} {f g : filter_basis α}

-- A filter B is a collection of subsets, 
-- so clearly we want to do something like U ∈ B. 
@[reducible]
instance : has_mem (set α) (filter_basis α) := ⟨λ U B, U ∈ B.sets⟩

-- We can prove that every filter is actually a filter basis.
/-- View a filter as a filter basis. -/
def filter.as_basis (f : filter α) : filter_basis α :=
⟨f.sets, ⟨univ, filter.univ_mem⟩, λ x y hx hy, ⟨x ∩ y, filter.inter_mem hx hy, subset_rfl⟩⟩

-- Let's make some APIs of as_basis for convenience:
lemma filter.mem_as_basis_iff (f : filter α) (t : set α) : 
  t ∈ filter.as_basis f ↔ t ∈ f := by refl

namespace filter_basis

@[simp] lemma mem_sets {s : set α} : s ∈ f.sets ↔ s ∈ f := iff.rfl

lemma filter_basis_eq : ∀ {f g : filter_basis α}, f.sets = g.sets → f = g
| ⟨a, _, _⟩ ⟨._, _, _⟩ rfl := rfl

-- two filter basis are equal if and only if they contain the same sets.
lemma filter_basis_eq_iff : f = g ↔ f.sets = g.sets :=
⟨congr_arg _, filter_basis_eq⟩

lemma ext_iff : f = g ↔ ∀ s, s ∈ f ↔ s ∈ g :=
by simp only [filter_basis_eq_iff, ext_iff, filter_basis.mem_sets]

@[ext]
lemma ext : (∀ s, s ∈ f ↔ s ∈ g) → f = g :=
filter_basis.ext_iff.2

-- We can construct filter using filter basis:
-- The filter F generated by filter base B is te collection of all sets Fⱼ such
-- that Bᵢ ⊆ Fⱼ for some Bᵢ ∈ B.
/-- The filter associated to a filter basis. -/
protected def filter (B : filter_basis α) : filter α :=
{ sets := {s | ∃ t ∈ B, t ⊆ s},
  univ_sets := 
  begin
    simp only [exists_prop, mem_set_of_eq, subset_univ, and_true],
    exact B.nonempty,
  end,
  upward_closure := 
  begin
    simp only [exists_prop, mem_set_of_eq, forall_exists_index, and_imp],
    intros F₁ F₂ x hx₁ hx₂ hF,
    refine ⟨x, hx₁, subset_trans hx₂ hF⟩,
  end,
  inter_sets := 
  begin
    simp only [exists_prop, mem_set_of_eq, subset_inter_iff, forall_exists_index, and_imp],
    intros F₁ F₂ x hx₁ hx₂ y hy₁ hy₂,
    obtain ⟨t, ht₁, ht₂⟩ := B.inter_sets hx₁ hy₁,
    rw subset_inter_iff at ht₂,
    cases ht₂ with ht₃ ht₄,
    refine ⟨t, ht₁, subset_trans ht₃ hx₂, subset_trans ht₄ hy₂⟩,
  end }

-- The following two lemmas are directly from the definition.
lemma mem_filter_iff (B : filter_basis α) {U : set α} : U ∈ B.filter ↔ ∃ s ∈ B, s ⊆ U :=
iff.rfl

lemma mem_filter_of_mem (B : filter_basis α) {U : set α} : U ∈ B → U ∈ B.filter:=
λ U_in, ⟨U, U_in, subset.refl _⟩

-- Next, we can try to prove this lemma:
/-- The filter generated by a filter f is actually f. -/
lemma generated_by_filter_eq (f : filter α) :
  filter_basis.filter (filter.as_basis f) = f :=
begin
  ext1,
  rw mem_filter_iff,
  split,
  { intro hs,
    obtain ⟨t, ht₁, ht₂⟩ := hs,
    rw filter.mem_as_basis_iff at ht₁,
    exact filter.mem_of_superset ht₁ ht₂ },
  { intro hs,
    rw ← filter.mem_as_basis_iff at hs,
    refine ⟨s, hs, by refl⟩ }
end

end filter_basis

/-
Now, we want to consider ≤ in filters.
When we say that a filter F ≤ filter G , it means that G is finer than or equal to F. 
In this context, being "finer" means having more sets that satisfy the conditions 
for being in the filter. The definition (every element of G is a subset of some 
element of F) captures the idea that G has, in some sense, 
more detailed or refined information than F.

This is analogous to the concept of refining a partition or a 
grid in topology or analysis. For example, in calculus, 
when we talk about partitions of an interval, a finer partition has more subintervals 
and is considered "smaller" than a coarser partition in the context of integration, even 
though it contains more elements.
-/

section order

-- Let's verify it satisfies partial order:
instance : partial_order (filter α) :=
{ le            := λ f g, ∀ ⦃U : set α⦄, U ∈ g → U ∈ f,
  le_antisymm   := λ a b h₁ h₂, filter.filter_eq $ subset.antisymm h₂ h₁,
  le_refl       := λ a, subset.rfl,
  le_trans      := λ a b c h₁ h₂, subset.trans h₂ h₁ }

theorem filter.le_def {f g : filter α}: f ≤ g ↔ ∀ x ∈ g, x ∈ f := iff.rfl

-- Similarly, we can define partial order on filter basis:
instance : partial_order (filter_basis α) :=
{ le            := λ B C, ∀ ⦃U : set α⦄, U ∈ C → U ∈ B,
  le_antisymm   := λ B C h₁ h₂, filter_basis.filter_basis_eq $ subset.antisymm h₂ h₁,
  le_refl       := λ B, subset.rfl,
  le_trans      := λ A B C h₁ h₂, subset.trans h₂ h₁ }

theorem filter_basis.le_def {f g : filter_basis α}: f ≤ g ↔ ∀ x ∈ g, x ∈ f := iff.rfl

namespace filter_basis

-- Next, let's think about how to prove this:
/--
If filter base B is a refinement of filter base C then the filter generated by B is finer
than the filter generated by C.
-/
lemma filter_le_filter {B C : filter_basis α} (h : B ≤ C) :
  filter_basis.filter B ≤ filter_basis.filter C :=
begin
  intros u hu,
  rw mem_filter_iff at hu ⊢,
  obtain ⟨s, hs₁, hs₂⟩ := hu,
  rw filter_basis.le_def at h,
  specialize h s hs₁,
  refine ⟨s, h, hs₂⟩,
end

-- Here is another puzzle:
/-- 
If B is a filter basis which generates filter F and G is any filter, then B ⊆ G
if and only if F ⊆ G.
-/
lemma as_basis_le_iff_le_filter (B : filter_basis α) (G : filter α) : 
  filter.as_basis G ≤ B ↔ G ≤ filter_basis.filter B :=
begin
  split,
  { intros h u hu,
    rw mem_filter_iff at hu,
    obtain ⟨s, hs₁, hs₂⟩ := hu,
    specialize h hs₁,
    rw filter.mem_as_basis_iff at h,
    exact filter.mem_of_superset h hs₂ },
  { intros h u hu,
    rw filter.mem_as_basis_iff,
    apply h,
    exact filter_basis.mem_filter_of_mem B hu }
end

end filter_basis
end order