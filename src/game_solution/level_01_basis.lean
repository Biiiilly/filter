/-
Copyright (c) 2023 Jiale Miao. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jiale Miao, Yichen Feng, Lily Frost, Archie Prime
Thanks: Kevin Buzzard
-/

import game_solution.level_00_basic

/-!
# Filter basis

We define the filter basis in this file.

# Main Definitions

`filter_basis` : the filter basis

-/

open set

-- Let's define the filter basis:
/-- A filter basis is a nonempty collection of sets such that the intersection of 
two elements of this collection contains some element of the collection. -/
structure filter_basis (α : Type*) :=
(sets                   : set (set α))
(nonempty               : sets.nonempty)
(inter_sets {x y}       : x ∈ sets → y ∈ sets → ∃ z ∈ sets, z ⊆ x ∩ y)

variables {α : Type*} {f g : filter_basis α}

-- A filter B is a collection of subsets, 
-- so clearly we want to do something like U ∈ B. 
@[reducible]
instance : has_mem (set α) (filter_basis α) := ⟨λ U B, U ∈ B.sets⟩

-- We can prove that every filter is actually a filter basis.
/-- View a filter as a filter basis. -/
def filter.as_basis (f : filter α) : filter_basis α :=
⟨f.sets, ⟨univ, filter.univ_mem⟩, λ x y hx hy, ⟨x ∩ y, filter.inter_mem hx hy, subset_rfl⟩⟩

-- Let's make some APIs of as_basis for convenience:
lemma filter.mem_as_basis_iff (f : filter α) (t : set α) : 
  t ∈ filter.as_basis f ↔ t ∈ f := by refl

namespace filter_basis

@[simp] lemma mem_sets {s : set α} : s ∈ f.sets ↔ s ∈ f := iff.rfl

lemma filter_basis_eq : ∀ {f g : filter_basis α}, f.sets = g.sets → f = g
| ⟨a, _, _⟩ ⟨._, _, _⟩ rfl := rfl

-- two filter basis are equal if and only if they contain the same sets.
lemma filter_basis_eq_iff : f = g ↔ f.sets = g.sets :=
⟨congr_arg _, filter_basis_eq⟩

lemma ext_iff : f = g ↔ ∀ s, s ∈ f ↔ s ∈ g :=
by simp only [filter_basis_eq_iff, ext_iff, filter_basis.mem_sets]

@[ext]
lemma ext : (∀ s, s ∈ f ↔ s ∈ g) → f = g :=
filter_basis.ext_iff.2

-- We can construct filter using filter basis:
-- The filter F generated by filter base B is te collection of all sets Fⱼ such
-- that Bᵢ ⊆ Fⱼ for some Bᵢ ∈ B.
/-- The filter associated to a filter basis. -/
protected def filter (B : filter_basis α) : filter α :=
{ sets := {s | ∃ t ∈ B, t ⊆ s},
  univ_sets := 
  begin
    simp only [exists_prop, mem_set_of_eq, subset_univ, and_true],
    exact B.nonempty,
  end,
  upward_closure := 
  begin
    simp only [exists_prop, mem_set_of_eq, forall_exists_index, and_imp],
    intros F₁ F₂ x hx₁ hx₂ hF,
    refine ⟨x, hx₁, subset_trans hx₂ hF⟩,
  end,
  inter_sets := 
  begin
    simp only [exists_prop, mem_set_of_eq, subset_inter_iff, forall_exists_index, and_imp],
    intros F₁ F₂ x hx₁ hx₂ y hy₁ hy₂,
    obtain ⟨t, ht₁, ht₂⟩ := B.inter_sets hx₁ hy₁,
    rw subset_inter_iff at ht₂,
    cases ht₂ with ht₃ ht₄,
    refine ⟨t, ht₁, subset_trans ht₃ hx₂, subset_trans ht₄ hy₂⟩,
  end }

-- The following two lemmas are directly from the definition.
lemma mem_filter_iff (B : filter_basis α) {U : set α} : U ∈ B.filter ↔ ∃ s ∈ B, s ⊆ U :=
iff.rfl

lemma mem_filter_of_mem (B : filter_basis α) {U : set α} : U ∈ B → U ∈ B.filter:=
λ U_in, ⟨U, U_in, subset.refl _⟩

-- Next, we can try to prove this lemma:
/-- The filter generated by a filter f is actually f. -/
lemma generated_by_filter_eq (f : filter α) :
  filter_basis.filter (filter.as_basis f) = f :=
begin
  ext1,
  rw mem_filter_iff,
  split,
  { intro hs,
    obtain ⟨t, ht₁, ht₂⟩ := hs,
    rw filter.mem_as_basis_iff at ht₁,
    exact filter.mem_of_superset ht₁ ht₂ },
  { intro hs,
    rw ← filter.mem_as_basis_iff at hs,
    refine ⟨s, hs, by refl⟩ }
end

end filter_basis
