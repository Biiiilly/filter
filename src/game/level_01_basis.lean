/-
Copyright (c) 2023 Jiale Miao. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jiale Miao, Yichen Feng, Lily Frost, Archie Prime
Thanks: Kevin Buzzard
-/

import game.level_00_basic

/-!
# Filter basis

We define the filter basis in this file.

# Main Definitions

`filter_basis` : A filter basis is a nonempty collection of sets such that the 
intersection of two elements of this collection contains 
some element of the collection.

-/

open set

-- Let's define the filter basis:
/-- A filter basis is a nonempty collection of sets such that the intersection of 
two elements of this collection contains some element of the collection. -/
structure filter_basis (α : Type*) :=
(sets                   : set (set α))
(nonempty               : sets.nonempty)
(inter_sets {x y}       : x ∈ sets → y ∈ sets → ∃ z ∈ sets, z ⊆ x ∩ y)

variables {α : Type*} {B C : filter_basis α}

-- A filter B is a collection of subsets, 
-- so clearly we want to do something like U ∈ B. 
instance : has_mem (set α) (filter_basis α) := ⟨λ U B, U ∈ B.sets⟩

-- We can prove that every filter is actually a filter basis.
/-- View a filter as a filter basis. -/
def filter.as_basis (f : filter α) : filter_basis α :=
⟨f.sets, 
begin
  sorry -- Prove nonempty
end, 
begin
  sorry -- Prove inter_sets
end⟩

-- Here are some APIs of filter basis:
lemma filter.mem_as_basis_iff (f : filter α) (t : set α) : 
  t ∈ filter.as_basis f ↔ t ∈ f :=
begin
  sorry
end

namespace filter_basis

@[simp] lemma mem_sets {s : set α} : s ∈ B.sets ↔ s ∈ B :=
begin
  sorry
end

lemma filter_basis_eq : ∀ {B C : filter_basis α}, B.sets = C.sets → B = C
| ⟨a, _, _⟩ ⟨._, _, _⟩ rfl := rfl

/-- Two filter basis are equal if and only if they contain the same sets. -/
lemma filter_basis_eq_iff : B = C ↔ B.sets = C.sets :=
⟨congr_arg _, filter_basis_eq⟩

-- Hint: try 'simp'
lemma ext_iff : B = C ↔ ∀ s, s ∈ B ↔ s ∈ C :=
begin
  sorry
end

@[ext]
lemma ext : (∀ s, s ∈ B ↔ s ∈ C) → B = C :=
filter_basis.ext_iff.2

/- Actually, we can construct filter using filter basis:
The filter f generated by filter base B is te collection of all sets fⱼ such
that Bᵢ ⊆ fⱼ for some Bᵢ ∈ B. -/

-- Try to solve these `sorry`s.
/-- The filter associated to a filter basis. -/
protected def filter (B : filter_basis α) : filter α :=
{ sets := {s | ∃ t ∈ B, t ⊆ s},
  univ_sets := 
  begin
    sorry
  end,
  upward_closure := 
  begin
    sorry
  end,
  inter_sets := 
  begin
    sorry
  end }

-- The following two lemmas are directly from the definition.
lemma mem_filter_iff (B : filter_basis α) {s : set α} : 
  s ∈ B.filter ↔ ∃ t ∈ B, t ⊆ s :=
begin
  sorry
end

lemma mem_filter_of_mem (B : filter_basis α) {s : set α} : s ∈ B → s ∈ B.filter :=
begin
  sorry
end

-- Next, we can try to prove this lemma:
/-- The filter generated by a filter is actually itself. -/
lemma generated_by_filter_eq (f : filter α) :
  filter_basis.filter (filter.as_basis f) = f :=
begin
  sorry
end

end filter_basis
